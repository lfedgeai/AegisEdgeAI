// Unified-Identity - Phase 1: SPIRE API & Policy Staging (Stubbed Keylime)
// Package workload contains sovereign attestation handling for the Unified Identity feature.
package workload

import (
	"context"
	"encoding/base64"
	"fmt"

	"github.com/sirupsen/logrus"
	"github.com/spiffe/go-spiffe/v2/proto/spiffe/workload"
	"github.com/spiffe/spire/pkg/common/fflag"
)

// generateStubbedSovereignAttestation generates a stubbed sovereign attestation
// for Phase 1 testing. This returns fixed test data that simulates a TPM quote
// and app key certificate.
func generateStubbedSovereignAttestation(ctx context.Context, log logrus.FieldLogger, req *workload.X509SVIDRequest) *workload.SovereignAttestation {
	// Unified-Identity - Phase 1: SPIRE API & Policy Staging (Stubbed Keylime)
	// Check if Unified-Identity feature flag is enabled
	if !fflag.IsSet(fflag.FlagUnifiedIdentity) {
		log.Debug("Unified-Identity feature flag is not enabled, skipping sovereign attestation generation")
		return nil
	}

	// If the request already contains sovereign attestation, use it
	if req != nil && req.SovereignAttestation != nil {
		log.Debug("Unified-Identity - Phase 1: Using sovereign attestation from request")
		return req.SovereignAttestation
	}

	// Unified-Identity - Phase 1: SPIRE API & Policy Staging (Stubbed Keylime)
	// Generate stubbed attestation data for Phase 1
	// In a real implementation, this would be generated by a TPM plugin
	log.Info("Unified-Identity - Phase 1: Generating stubbed sovereign attestation")

	// Stubbed TPM quote (base64-encoded)
	stubbedTPMQuote := base64.StdEncoding.EncodeToString([]byte("stubbed-tpm-quote-for-phase-1-testing"))

	// Stubbed App Key public key (PEM format)
	stubbedAppKeyPublic := `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAstubbedPublicKeyForPhase1Testing
-----END PUBLIC KEY-----`

	// Stubbed App Key certificate (base64-encoded DER)
	stubbedAppKeyCert := base64.StdEncoding.EncodeToString([]byte("stubbed-app-key-certificate-der"))

	// Stubbed challenge nonce (in real implementation, this comes from Server)
	stubbedNonce := "stubbed-challenge-nonce-phase-1"

	attestation := &workload.SovereignAttestation{
		TpmSignedAttestation: stubbedTPMQuote,
		AppKeyPublic:         stubbedAppKeyPublic,
		AppKeyCertificate:    []byte(stubbedAppKeyCert),
		ChallengeNonce:       stubbedNonce,
		WorkloadCodeHash:     "", // Optional, can be set by workload
	}

	log.WithFields(logrus.Fields{
		"has_tpm_quote":      attestation.TpmSignedAttestation != "",
		"has_app_key":        attestation.AppKeyPublic != "",
		"has_app_key_cert":   len(attestation.AppKeyCertificate) > 0,
		"has_nonce":          attestation.ChallengeNonce != "",
		"workload_code_hash": attestation.WorkloadCodeHash,
	}).Info("Unified-Identity - Phase 1: Generated stubbed sovereign attestation")

	return attestation
}

// processSovereignAttestation processes the sovereign attestation from the request
// and returns it for forwarding to the Server. For Phase 1, this is a pass-through
// with logging.
func processSovereignAttestation(ctx context.Context, log logrus.FieldLogger, req *workload.X509SVIDRequest) (*workload.SovereignAttestation, error) {
	// Unified-Identity - Phase 1: SPIRE API & Policy Staging (Stubbed Keylime)
	if !fflag.IsSet(fflag.FlagUnifiedIdentity) {
		return nil, nil
	}

	if req == nil {
		return nil, nil
	}

	// If request contains sovereign attestation, validate it
	if req.SovereignAttestation != nil {
		if err := validateSovereignAttestation(req.SovereignAttestation); err != nil {
			log.WithError(err).Error("Unified-Identity - Phase 1: Invalid sovereign attestation in request")
			return nil, fmt.Errorf("invalid sovereign attestation: %w", err)
		}

		log.WithFields(logrus.Fields{
			"has_tpm_quote":      req.SovereignAttestation.TpmSignedAttestation != "",
			"has_app_key":        req.SovereignAttestation.AppKeyPublic != "",
			"has_app_key_cert":   len(req.SovereignAttestation.AppKeyCertificate) > 0,
			"has_nonce":          req.SovereignAttestation.ChallengeNonce != "",
			"workload_code_hash": req.SovereignAttestation.WorkloadCodeHash,
		}).Debug("Unified-Identity - Phase 1: Processing sovereign attestation from request")

		return req.SovereignAttestation, nil
	}

	// Generate stubbed attestation if not provided
	return generateStubbedSovereignAttestation(ctx, log, req), nil
}

// validateSovereignAttestation validates the sovereign attestation structure
func validateSovereignAttestation(attestation *workload.SovereignAttestation) error {
	if attestation == nil {
		return fmt.Errorf("attestation cannot be nil")
	}

	if attestation.TpmSignedAttestation == "" {
		return fmt.Errorf("tpm_signed_attestation is required")
	}

	// Validate base64 encoding
	if _, err := base64.StdEncoding.DecodeString(attestation.TpmSignedAttestation); err != nil {
		return fmt.Errorf("tpm_signed_attestation must be valid base64: %w", err)
	}

	// Validate size (max 64 KiB)
	if len(attestation.TpmSignedAttestation) > 64*1024 {
		return fmt.Errorf("tpm_signed_attestation exceeds maximum size of 64 KiB")
	}

	if attestation.ChallengeNonce == "" {
		return fmt.Errorf("challenge_nonce is required")
	}

	if attestation.AppKeyPublic == "" {
		return fmt.Errorf("app_key_public is required")
	}

	return nil
}

